<!doctype html>
<meta charset="utf-8">
<script src="https://ajaxorg.github.io/ace-builds/src/ace.js"></script>
<script src="https://ajaxorg.github.io/ace-builds/src/ext-language_tools.js"></script>
<script src="https://ajaxorg.github.io/ace-builds/src/ext-diff.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css"  crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" crossorigin="anonymous"></script>


<div id="container">
    <div id="sidePanel"></div>
    <div id='example'>

Example


\[{{\gamma }_{1}}=\frac{1}{2\pi }\arg ,\] (1.1)


Fig. 1. some text \[\int_L dL\]
Figure. 2 more text

paragraph % \[\int_L dL\] 1 \[\int_L dL\] (1.2) 

paragraph 2 $eq$ (1.2) [1-2] and [2]

Fig. 3 description

see (Fig.1) for explanation

${{\gamma }_{1}}=\frac{1}{2\pi }\arg ,$ (1.2)


\begin{table}[!h]
\centering
\caption{
${{\bar{\sigma }}_{R\left( \upsilon  \right)}}={{\varphi }_{9}}\left( lg{{{\bar{N}}}_{G\left( \upsilon  \right)}} \right)$ is the regression equation of the function
}
\label{tab:1}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
№	&	${{d}_{i}}$, mm	&	$\Delta {{h}_{i}}$, mm	&	${{\bar{a}}_{\sigma i~~}}$	&	Regression equation	&	${{R}^{2}}$\\ 
 \hline
1	&	7,5	&	\multirow{4}{*}{0}	&	1,00	&	${{\bar{\sigma }}_{R\left( \upsilon  \right)}}=290,19x-1442,00$	&	0,965\\ 
 \cline{1-2}
\cline{4-6}
2	&	10,0	&		&	1,25	&	${{\bar{\sigma }}_{R\left( \upsilon  \right)}}=405,01x-2196,80$	&	0,977\\ 
 \cline{1-2}
\cline{4-6}
3	&	15,0	&		&	1,75	&	${{\bar{\sigma }}_{R\left( \upsilon  \right)}}=366,12x-2017,60$	&	0,985\\ 
 \cline{1-2}
\cline{4-6}
4	&	20,0	&		&	2,75	&	${{\bar{\sigma }}_{R\left( \upsilon  \right)}}=373,32x-2155,40$	&	0,958\\ 
 \hline
5	&	7,5	&	\multirow{4}{*}{0,05}	&	1,00	&	${{\bar{\sigma }}_{R\left( \upsilon  \right)}}=-6049,10{{x}^{2}}+73903,00x-225290,00$	&	0,988\\ 
 \cline{1-2}
\cline{4-6}
6	&	10,0	&		&	1,25	&	${{\bar{\sigma }}_{R\left( \upsilon  \right)}}=119,00x-377,80$	&	0,914\\ 
 \cline{1-2}
\cline{4-6}
7	&	15,0	&		&	1,75	&	${{\bar{\sigma }}_{R\left( \upsilon  \right)}}=204,67x-936,46$	&	0,995\\ 
 \cline{1-2}
\cline{4-6}
8	&	20,0	&		&	2,75	&	${{\bar{\sigma }}_{R\left( \upsilon  \right)}}=222,28x-1130,8$	&	0,986\\ 
 \hline
9	&	7,5	&	\multirow{4}{*}{0,10}	&	1,00	&	${{\bar{\sigma }}_{R\left( \upsilon  \right)}}=188,86x-718,04$	&	0,974\\ 
 \cline{1-2}
\cline{4-6}
10	&	10,0	&		&	1,25	&	${{\bar{\sigma }}_{R\left( \upsilon  \right)}}=95,86x-228,18$	&	0,986\\ 
 \cline{1-2}
\cline{4-6}
11	&	15,0	&		&	1,75	&	${{\bar{\sigma }}_{R\left( \upsilon  \right)}}=286,24x-1412,60$	&	0,972\\ 
 \cline{1-2}
\cline{4-6}
12	&	20,0	&		&	2,75	&	${{\bar{\sigma }}_{R\left( \upsilon  \right)}}=206,93x-1027,00$	&	0,950\\ 
 \hline
13	&	7,5	&	\multirow{4}{*}{0,15}	&	1,00	&	${{\bar{\sigma }}_{R\left( \upsilon  \right)}}=127,64x-339,85$	&	0,998\\ 
 \cline{1-2}
\cline{4-6}
14	&	10,0	&		&	1,25	&	${{\bar{\sigma }}_{R\left( \upsilon  \right)}}=218,61x-953,18$	&	0,986\\ 
 \cline{1-2}
\cline{4-6}
15	&	15,0	&		&	1,75	&	${{\bar{\sigma }}_{R\left( \upsilon  \right)}}=219,71x-978,17$	&	0,979\\ 
 \cline{1-2}
\cline{4-6}
16	&	20,0	&		&	2,75	&	${{\bar{\sigma }}_{R\left( \upsilon  \right)}}=181,96x-852,66$	&	0,992\\ 
 \hline
 \end{tabular}
\end{table}

References

1. Galin L.A. Contact problems of the theory of elasticity and viscoelasticity.-M.: Nauka, 1980.- 304 p. (In Russian)

2. Shtaerman I.Ya. Contact problem of elasticity theory. - M.-L.: Gostekhteorizdat, 1947 - 270 p. (In Russian)
		
		
	
	</div>
</div>
<style>
	body {
		margin: 0;
	}
	
    #container {
        display: flex;
        height: 100vh;
        align-items: stretch;
    }

    #example {
        flex: 1;
    }

    #sidePanel {
        background: rebeccapurple;
        overflow: auto;
		color: white;
		padding-left: 8px
    }

	button {
		margin-top: 5px;
	}

</style>
<script>
var editor = ace.edit("example", {
    theme: "ace/theme/textmate",
    mode: "ace/mode/latex",
    wrap: localStorage.wrap !== "false",
    enableBasicAutocompletion: true,
});

ace.config.loadModule("ace/ext/searchbox", function (e) { 
	e.Search(editor);
	editor.searchBox.searchInput.value = "" 
});


if (localStorage.lastValue) {
	editor.setValue(localStorage.lastValue, -1);
	if (localStorage.lastSelection) {
		try {
			let sel = JSON.parse(localStorage.lastSelection)
			editor.selection.fromJSON(sel)
		} catch(e) {
			console.error(e)
		}
	}
	editor.session.setScrollTop(localStorage.scrollTop || 0)
}

function applyInclusionRe(value, inclusionRe) {
    inclusionRe.lastIndex = 0;
    var m 
    var newValue = ""
    var lastIndex = 0
    while((m = inclusionRe.exec(value))) {
        newValue += "\x01".repeat(m.index - lastIndex)
        newValue += m[0]
        lastIndex = m.index + m[0].length
    }
    return newValue
}

function findNext(eqreg, excludeRe, inclusionRe) {
    value = editor.getValue()

    if (excludeRe) {
        value = value.replace(excludeRe, function(_) {
            return _.replace(/./g, " ")
        })
    }
	if (inclusionRe) {
		value = applyInclusionRe(value, inclusionRe)
	}

    lastIndex = editor.session.doc.positionToIndex(editor.selection.getRange().end) 

    eqreg.lastIndex = lastIndex

    match = eqreg.exec(value)
    lastIndex = eqreg.lastIndex

    if (!match) match = {index: 0, 0: "", fake: true};

    start = editor.session.doc.indexToPosition(match.index) 
    end = editor.session.doc.indexToPosition(match.index + match[0].length) 
    editor.selection.setRange({start, end})

    editor.renderer.scrollCursorIntoView(null, 0.5)
    
    lastRe = eqreg

    return !match.fake;
}

function updateSearch(eqreg) {
    if (!eqreg) eqreg = lastRe
	if (searchValue != eqreg.source) {
		searchValue = eqreg.source
	}
	searchTimeout = searchTimeout || setTimeout(function() {
		searchTimeout = null;
		editor.searchBox.searchInput.value = eqreg.source
		editor.searchBox.regExpOption.checked = true;
        editor.searchBox.find = function() {}
        try  {
		    editor.searchBox.$syncOptions()
        } finally {
            delete editor.searchBox.find;
        }
	})
}
var lastRe
var searchValue
var searchTimeout

var eqReg = / *(\\\[(?:[^\\]|\\[^\]])+\\\]|\$[^$]+\$)([\s,.;]*)(\(\d+(?:\.[\d.]*)?\w*\))/g 
var eqRegStrict = /^[ \t]*(\\\[(?:[^\\]|\\[^\]])+\\\]|\$[^$]+\$)([\s,.;]*)(\(\d+(?:\.[\d.]*)?\w*\))[ \t]*$/gm
var sectionReg = /^(\d+(?:\.[\d.]*)?)(.*)/gm

var numberReg =/(\(\d+(?:\.[\d.]*)?\w*\))/g 
var numberRegUnStrict = /(\(\s*\d+(?:\.[\d.]*)?\w*\)\s*)/g

var inlineEqReg=/ *(\\\[(?:[^\\]|\\[^\]])+\\\]|\$[^$]+\$)([ ;,.]*)/g 
var inlineEqStartReg=/(^[ \t]*(\$[^$]+\$)|\\\[(?:[^\\]|\\[^\]])+\\\](?= *\w)|(?<=\w +)\\\[(?:[^\\]|\\[^\]])+\\\])([ \t,.;]*)(\(\d+(?:\.[\d.]*)?\w*\))?/gm 

var eqAndBibExclusionRe = /\\begin{(equation\*?|tabular|figure)[\s\S]*?\\end{\1}|\$[^$]+\$|\\begin{thebibliography}[\s\S]*/g

var eqInclusionRe = /\\begin{(equation\*?|align)[\s\S]*?\\end{\1}|\$[^$]+\$|\\\[(?:[^\\]|\\[^\]])+\\\]/g


var displayEqReg=/^\s*(\$[^$]+\$)\s*$/gm

var container = document.getElementById("container")
var sidePanel = document.getElementById("sidePanel")
if (!sidePanel) {
    sidePanel = document.createElement("div")
    sidePanel.id="sidePanel"
    document.body.appendChild(sidePanel)
    sidePanel.style.cssText="    position: absolute;    background: beige;"
}
sidePanel.innerHTML = ""
if (!window.dom) dom = ace.require("ace/lib/dom")

//editor = document.querySelector(".ace_editor").env.editor

function formatRefNumber(str) {
    return str.trim().replace(/\.+$/, "").replace(/\./g, "_").trim()
}

function replaceNumberedEquation() {
	var line = editor.getSelectedText()
	eqReg.lastIndex = 0
	var match = eqReg.exec(line)
	var number = "eq" + match[3].replace(/[()]/g, "") .replace(/[\.]/g, "_")
	var punct = match[2].trim()
	var eq = match[1].trim().replace(/^(\\\[|\$)/, "").replace(/(\\\]|\$)$/, "").trim()

	var replacement = `\\begin{equation} \\label{${number}}\n${eq + punct}\n\\end{equation}`
	editor.insert(replacement)
}
function convertToInline() {
	var line = editor.getSelectedText()
	inlineEqReg.lastIndex = 0
	var match = inlineEqReg.exec(line)
	var punct = match[2].trim()
    var tail = line.slice(inlineEqReg.lastIndex).trim()
	
	var eq = match[1].trim().replace(/^(\\\[|\$)/, "").replace(/(\\\]|\$)$/, "").trim()

	var replacement = ` $${eq}$` + punct + " " + tail
	editor.insert(replacement)
}
function convertToDisplay() {
	var line = editor.getSelectedText()
	inlineEqReg.lastIndex = 0
	var match = inlineEqReg.exec(line)
    var tail = line.slice(inlineEqReg.lastIndex).trim()
    // check if tail contains numbered equation
    if (tail) {
        eqReg.lastIndex = 0
	    var match2 = eqReg.exec(line)
        if (match2?.[3]) {
            return replaceNumberedEquation();
        }
    }

	var punct = match[2].trim()
	
	var eq = match[1].trim().replace(/^(\\\[|\$)/, "").replace(/(\\\]|\$)$/, "").trim()

	var replacement = `\\begin{equation*}\n${eq + punct}\n\\end{equation*}` + (tail ? "\n" + tail : "")
	editor.insert(replacement)
}

function mergeEquations() {
    var line = editor.getSelectedText();
    var m 
    eqInclusionRe.lastIndex = 0
    var lastIndex = 0
    var result = ""
    while((m = eqInclusionRe.exec(line))) {
        var textBefore = line.slice(lastIndex, m.index)
        if (textBefore) {
            textBefore = ` \\text{ ${textBefore} } `.replace(/\n/g, "}\\\\\n\\text{ ")
            result += textBefore;
        }
        var eqText = m[0];
        eqText = eqText.replace(/^(\$|\\\[|\\begin{(equation)\*?})\s*/s, "")
            .replace(/(\$|\\\]|\\end{(equation).*)$/s, "")
            .replace(/\\label{[^}]*}/g, "")
        result +=  eqText + " "
        lastIndex = eqInclusionRe.lastIndex
    }
    var textBefore = line.slice(lastIndex);
    if (textBefore) {
        result += ` \\text{ ${textBefore} } `
    }

    // normalize punctuation
    result = result.replace(/\s+([,.;:!?])/g, "$1")
        .replace(/\\text{\s*([,.;:!?])/g, "$1 \\text{")

    editor.insert("$" + result + "$");
}

function bookCitation() {
	var line = editor.getSelectedText()
	var match = /\[([\d\,\-\s\–]*)\]/g.exec(line)
	var books = match[1].replace(/\s+/g, "").replace(/(\d+)(?:-+|–)(\d+)/g, function(_, a, b) {
		a = parseInt(a)
		b = parseInt(b)
		if (a > b) throw a
		var r = [] 
		for (var  i = a; i <= b; i++) {
			r.push(i)
		}
		return r.join(",") 
	} ).replace(/\d+/g, x=>"book" + x)
	var replacement = "\\cite{" + books +"}"

	editor.insert(replacement)
}

dom.buildDom([
"div", {onclick: ()=> editor.focus()},	
["button", {onclick: function() {
       
       initialize()
       findNext(/^[ \t]*(References|Literature|литература)(\s*\d+\..*)+/mi)
    }}, "initialize"],   
"      \x1a     \x1a \x1a  ",
["button", {onclick: function() {
       
       initializeFromHTML()
       findNext(/^[ \t]*(References|Literature|литература)(\s*\d+\..*)+/mi)
    }}, "from html"],   
    
    ["hr"], // bibliography

	["button", {onclick: function() {
        
		var text = editor.getSelectedText()

		text = text
            .replace(/^\s*(References|Literature|литература)/i, "")
            .replace(/\n+\s*(\d+)\.?/gm, function(_, number) {
                return "\n\n\\bibitem{book" + number +"}\n"
            });

		var replacement = "\\begin{thebibliography}{1}\n"
			+ text
			+ "\n\\end{thebibliography}"

		editor.insert(replacement)
        editor.focus()
    }}, "bibliography"],

    ["br"],

    ["button", {onclick: function() {
        bookCitation();
        editor.renderer.scrollCursorIntoView(null, 0.5)
        
        editor.focus()
    }}, "cite"],


    ["button", {onclick: function() {
        findNext(/\[[\d\,\-\s\–]*\]/g, eqAndBibExclusionRe)
        updateSearch()
        editor.focus()
    }}, "next"],

	"      \x1a     \x1a \x1a  ",

	["button", {onclick: function() {
		editor.selection.moveTo(0, 0)
		var max = 10000
       	while(findNext(/\[[\d\,\-\s\–]*\]/g, eqAndBibExclusionRe) && max-- >0) {
			bookCitation();
		}
       	editor.focus()
    }}, "all"],

    ["br"],



    ["hr"], // section
    ["button", {onclick: function() {
       
        var line = editor.getSelectedText().trim()
        sectionReg.lastIndex = 0
        var match = sectionReg.exec(line)
        if (match) {
            var number = match[1]
            var caption = match[2].trim()
            editor.insert(`\\section{\n    ${caption}\n}\\label{part${number}}\n`)
        } else {
            editor.insert(`\\section{\n    ${line}\n}\n`)
        }
        editor.renderer.scrollCursorIntoView(null, 0.5)
        editor.focus()

        // findNext(sectionReg)
    }}, "section"],
    ["button", {onclick: function() {
       findNext(sectionReg, eqAndBibExclusionRe)
       updateSearch()
       editor.focus()
    }}, "next"],
    "\x1a",
    ["button", {onclick: function() {
        editor.insertSnippet("\\textbf{$SELECTION}")
    }}, "bold"],
    ["button", {onclick: function() {
        editor.insertSnippet("\\textit{$SELECTION}")
    }}, "italic"],

    ["hr"],
	"Equations",

    ["br"],

    ["button", {onclick: function() {
       	findNext(inlineEqStartReg)
       	editor.focus()
    }}, "next broken"],
    "\xa0",
    ["button", {onclick: function() {
       	findNext(eqReg)
        updateSearch()
       	editor.focus()
    }}, "next numbered"],


    ["br"],

    ["button", {onclick: function() {
		convertToDisplay();
        editor.renderer.scrollCursorIntoView(null, 0.5)
       	editor.focus();
    }}, "display"],
    
    ["button", {onclick: function() {
		convertToInline()
        editor.renderer.scrollCursorIntoView(null, 0.5)
       	editor.focus() 
    }}, "inline"],

    ["button", {onclick: function() {
       	findNext(inlineEqReg)
       	editor.focus()
        updateSearch()
    }}, "next"],
    ["br"],

    ["br"],



	["button", {onclick: function() {
		replaceEqRef() 
        editor.renderer.scrollCursorIntoView(null, 0.5)
        editor.focus()
    }}, "eq ref"],

    ["button", {onclick: function() {
       	findNext(eqRefReg, eqAndBibExclusionRe)
       	editor.focus()
        updateSearch()
    }}, "next"],
	"   \x1b  \x1b  \x1b  \x1b  ",

    ["button", {onclick: function() {
		editor.selection.moveTo(0, 0)
		var max = 10000
		var data = {}
       	while(findNext(eqRefReg, eqAndBibExclusionRe) && max-- >0) {
			replaceEqRef(data) 
		}
		console.log(max)
    }}, "all"],



    ["hr"],
	"Tables and Figures",
    ["br"],

    ["button", {onclick: function() {
        var figureRe = /(?:FIGURE|Fig|фиг)\.?\s*(\d[\d.]*\w?)(.*)/i
        var line = editor.getSelectedText().replace(/\n/g, " ")
        var match = figureRe.exec(line)
        var number = formatRefNumber(match[1])
        var caption = match[2].trim().replace(/^}|\\textbf{}/g, "").trim()

        if (figureRe.test(caption)) {
            var match2 = figureRe.exec(caption)
            var number2 = formatRefNumber(match2[1])
            var caption2 =  match2[2].trim().replace(/^}|\\textbf{}/g, "").trim()
            caption = caption.slice(0, match2.index).trim()

            var pageType = /[^\d]$/.test(number) ? "subfigure" : "minipage"
    
            var replacement = `\\begin{figure}[h]
    \\centering
    \\begin{${pageType}}{.45\\textwidth}
        \\centering
        \\includegraphics[width=.9\\linewidth]{fig_${number}}
        \\caption{ 
            ${caption} 
        }
        \\label{fig_${number}}
    \\end{${pageType}}
    \\begin{${pageType}}{.45\\textwidth}
        \\centering
        \\includegraphics[width=.9\\linewidth]{fig_${number2}}
        \\caption{
            ${caption2}
        }
        \\label{fig_${number2}}
    \\end{${pageType}}
\\end{figure}`
         } else {
        var replacement = `\\begin{figure}[h]
    \\centering
    \\includegraphics[scale=.4]{fig_${number}}
    \\caption{
        ${caption}
    }
    \\label{fig_${number}}
\\end{figure}`
        }

        editor.insert(replacement)
        editor.renderer.scrollCursorIntoView(null, 0.5)
        editor.focus()
    }}, "figure"],

    ["button", {onclick: function() {
        findNext(/(FIGURES?|FIG|TABLES?|TAB|фиг(?:ура)?|Таб(?:лица)?)\.?\s*\d[\d\.]*[a-z]?(?:\s*(?:and|-|,)\s*([\d\.]+[a-z]?))?/ig)
        editor.focus()
        updateSearch()
    }}, "next"],
    ["span", "\xa0\xa0\xa0\xa0\xa0\xa0"],
    ["button", {onclick: function() {
        
        var figureRe = /((?:FIGURES?|FIG|TABLES?|TAB|фиг(?:ура)?|Таб(?:лица)?)\.?)\s*([\d\.]+[a-z]?)(?:\s*(and|-|,)\s*([\d\.]+[a-z]?))?/ig
        var line = editor.getSelectedText().replace(/\n/g, " ")
        if (line.slice(-1) == ".") {
            line = line.slice(0,-1)
            var r = editor.selection.getRange(); r.end.column--; editor.selection.setRange(r) 
        }
        
        var match = figureRe.exec(line)
        var figName = match[1]
        var number = formatRefNumber(match[2])
        var link = match[3]
        var number2 = formatRefNumber(match[4] || "")

        var identifier = /fig|фиг/.test(figName) ? "fig_" : "tab:"

        var replacement = figName + " \\ref{" + identifier + number + "}"

        if (number2) replacement += (link == "-" ? "-" : link == ","? ", " : " " + link + " ") + "\\ref{" + identifier + number2 + "}"
        
        editor.insert(replacement)
        editor.renderer.scrollCursorIntoView(null, 0.5)
        editor.focus()
    }}, "ref"],


	["br"],
    ["hr"],
 

    ["br"],
    ["button", {onclick: function() {
       	findNext(/[^\x00-\xff\s]/g)
       	editor.focus()
    }}, "next non-english"],
    ["br"],
    ["button", {onclick: function() {
        do {
            findNext(/(\\\[(?:[^\\]|\\[^\]])+\\\]|\$[^$]+\$|\\begin{equation[\s\S]*?\\end{equation)|(\. *\n)(?=[ \t]*\S)/g)
            var text = editor.getSelectedText()
        } while(text && !/^(\. *\n)/.test(text))
       	editor.focus()
    }}, "next paragraph"],
    ["br"],


    ["hr"],
    ["button", {onclick: function() {
        var text = editor


       
        var line = editor.getSelectedText()
        expRe.lastIndex=0
        var m = expRe.exec(line)
        console.log(m)
        var contents = (m[1] || m[2])
        if (!contents) return;

        var replacement = "e^{" + contents + "}"

        var sel = editor.selection.toJSON();

        var reg = ace.require("ace/lib/lang").escapeRegExp(line);
        var reg = new RegExp(reg)

        editor.selection.moveTo(0, 0)
		var max = 10000
		var data = {}
       	while(findNext(reg) && max-- >0) {
			editor.insert(replacement)
		} 
        
        editor.selection.fromJSON(sel); 
        // sectionReg.lastIndex = 0
        // var match = sectionReg.exec(line)
        // var number = match[1] 
        // var caption = match[2].trim()

        // editor.insert(`\\section{ ${caption} }\n`+`\\label{part${number}}\n`)
        editor.renderer.scrollCursorIntoView(null, 0.5)
        
        editor.focus()

    }}, "exp to e"],

    ["button", {onclick: function() {
        findNext(expRe)
        editor.focus()
        updateSearch()
    }}, "next"],

    ["br"],

	["button", {onclick: function() {
		replaceShOrCh() 
        editor.renderer.scrollCursorIntoView(null, 0.5)
        editor.focus()
    }}, "sh|ch"],

    ["button", {onclick: function() {
       	findNext(shOrChRegLoose, null, eqInclusionRe)
       	editor.focus()
        updateSearch()
    }}, "next"],
	"   \x1b  \x1b  \x1b  \x1b  ",

    ["button", {onclick: function() {
		editor.selection.moveTo(0, 0)
		var max = 10000
		var data = {}
       	while(findNext(shOrChReg, null, eqInclusionRe) && max-- >0) {
			replaceShOrCh(data) 
		}
		console.log(max)
    }}, "all"],
    
    ["hr"],
    
    ["button", {onclick: importTableFromHTML}, "import table"],
    


    ["br"],


    ["button", {onclick: function() {
        var replacement = convertToTable(editor.getSelectedText())
        if (replacement) {
            editor.insert(replacement)
        }
        editor.renderer.scrollCursorIntoView(null, 0.5)
        editor.focus()
    }}, "table"],

    ["button", {onclick: function() {
        var replacement = convertToLongTable(editor.getSelectedText())
        if (replacement) {
            editor.insert(replacement)
        }
        editor.renderer.scrollCursorIntoView(null, 0.5)
        editor.focus()
    }}, "longtable"],


	["hr"],

    ["button", {onclick: function() {
		editor.selection.moveTo(0, 0)
		var max = 10000
       	while(findNext(eqRegStrict) && max-- >0) {
			replaceNumberedEquation() 
		}
    }}, "all numb"],
    ["button", {onclick: function() {
		editor.selection.moveTo(0, 0)
		var max = 10000
       	while(findNext(displayEqReg) && max-- >0) {
			convertToDisplay()
		}
       	editor.focus()
    }}, "all display"],

	["button", {onclick: function() {
		editor.selection.moveTo(0, 0)
		var max = 10000
       	while(findNext(inlineEqReg) && max-- >0) {
			convertToInline() 
		}
       	editor.focus()
    }}, "all inline"],

    ["br"],
	["button", {onclick: function() {
		mergeEquations()
       	editor.focus()
    }}, "mergeEquations"],
	["button", {onclick: function() {
		editor.insertSnippet("\\begin{aligned}\n${0:$SELECTION}\n\\end{aligned}")
       	editor.focus()
    }}, "aligned"],

    ["br"],
    ["br"],
    ["hr"],
    "Settings:",
    ["br"],
    ["input", {
        id: "wrapOption", 
        type: "checkbox", 
        checked: localStorage.wrap == "false" ? null : true,
        onchange: function(e) {
            editor.session.setOption("wrap", e.target.checked)
            localStorage.wrap = e.target.checked
        }
    }],
    ["label", {for: "wrapOption"}, "Wrap text"],
    ["br"],
    ["hr"],
    ["button", {onclick: function() {
        toggleDiffView()
    }}, "Toggle Diff View"],
    ["br"],
    ["br"],
    ["br"],
    ["br"],
], sidePanel)

if (localStorage.panelScrollTop) {
    sidePanel.scrollTop = localStorage.panelScrollTop
}

var shOrChReg = /\\(?:text|operatorname){(sh|ch|cth|th|ctg|tg|arctg|sin|cos)} *|(?<!\\\w*)(sh|ch|cth|th|ctg|tg|arctg|sin|cos)\b */g
var shOrChRegLoose = /\\(?:text|operatorname){(sh|ch|cth|th|ctg|tg|arctg|sin|cos)} *|(?<!\\\w*)(sh|ch|cth|th|ctg|tg|arctg|sin|cos) */g


var expRe = /\\exp\s*(?:\(([^)]*)\)|\\left\(([^)]*)\\right\))/g

function replaceShOrCh() {
    var e = editor.getSelectedText();
    if (!e) return
    shOrChReg.lastIndex = 0;
    var match = shOrChReg.exec(e)
    var matchValue = match[1] || match[2];
    var replacement;
    if (matchValue == "sh") replacement = "\\sinh ";
    if (matchValue == "ch") replacement = "\\cosh ";
    if (matchValue == "cth") replacement = "\\coth ";
    if (matchValue == "th") replacement = "\\tanh ";
    if (matchValue == "ctg") replacement = "\\cot ";
    if (matchValue == "tg") replacement = "\\tan ";
    if (matchValue == "arctg") replacement = "\\arctan ";
    if (matchValue == "sin") replacement = "\\sin ";
    if (matchValue == "cos") replacement = "\\cos ";

    if (!replacement) return;
    editor.insert(replacement)
}


function replaceBibItem() {
    var line = editor.getSelectedText()
    var replacement = line.replace(/\n+(\d+)\.?/gm, function(_, number) {
        return "\n\n\\bibitem{book" + number +"}\n"
    });
    
    editor.insert(replacement)
}

function initialize() {
    var v=editor.getValue();
    var v1=v.replace(/’/g, "'").replace(/β/g, '$\beta$')

    v1 = v1.replace(/(\\\[(?:[^\\]|\\[^\]])+\\\]|\$[^$]+\$|\\begin{equation[\s\S]*?\\end{equation)|(\. *\n)(?=[ \t]*[^\s}\])$])/g, function(a,_,b) { if(b) return b + "\n"; return a })
    v1 = v1.replace(/{align}/g, "{aligned}")
    v1 = v1.replace(/(?<!\\)%/g, "\\%")
    // v1 = v1.replace(/а/g, "a")
    v1 = v1.replace(/–/g, "--")
    v1 = v1.replace(/[“”]/g, '"')
    v1 = v1.replace(/[‘’]/g, "'")
    v1 = v1.replace(/…/g, "\\ldots ")
    v1 = v1.replace(/×/g, "\\times ")
    v1 = v1.replace(/°/g, "\\degree ")
    v1 = v1.replace(/μ/g, "\\mu ")
    v1 = v1.replace(/≤/g, "\\leq ")
    v1 = v1.replace(/≥/g, "\\geq ")
    v1 = v1.replace(/≪/g, "\\ll ")
    v1 = v1.replace(/≫/g, "\\gg ")
    v1 = v1.replace(/≠/g, "\\neq ")
    v1 = v1.replace(/±/g, "\\pm ")
    v1 = v1.replace(/∑/g, "\\sum ")
    v1 = v1.replace(/√/g, "\\sqrt ")
    v1 = v1.replace(/∫/g, "\\int ")
    v1 = v1.replace(/∂/g, "\\partial ")
    v1 = v1.replace(/∞/g, "\\infty ")
    v1 = v1.replace(/∇/g, "\\nabla ")
    v1 = v1.replace(/\xa0/g, " ")

    v1 = v1.replace(/(\n[ \t]*){5,}/g, "\n\n\n\n\n")


    if (!/begin\{document}/.test(v1)) {
        v1=`\\documentclass[12pt,a4paper]{article}
\\usepackage[utf8]{inputenc}
\\usepackage[T1]{fontenc}
\\usepackage{amsmath}
\\usepackage{amsfonts}
\\usepackage{amssymb}
\\usepackage{graphicx}
\\usepackage{longtable}
\\usepackage{multirow}

% \\usepackage{diagbox}
% \\newcommand{\\Chi}{\\mathrm{X}}
% \\newcommand{\\Alpha}{\\mathrm{A}}
% \\usepackage{unicode-math}
% \\newcommand{\\sgn}{\\mathop{sgn}}

  
\\usepackage{caption}
\\captionsetup[figure]{font=scriptsize}
\\captionsetup[figure]{font=footnotesize}


% \\renewcommand{\\theequation}{\\thesection.{\\arabic{equation}}}
% \\numberwithin{equation}{section}


\\title{ 
    <Title here> 
}
\\author{ 
    <author1>
    \\and <author2>
}

\\begin{document}
\\maketitle

\\begin{abstract}
    <put abstract here>
\\end{abstract}

${v1}

\\end{document}
`
    }

    if (v!=v1) editor.setValue(v1)
}

var eqRefReg = /\(\d+[.\d]*\w*\)/g
function replaceEqRef(data) {
	if (!data) data = {}
	var results = data.results;
	if (!results) {
		results = data.results = computeLabels()
	} 
	var e = editor.getSelectedText();
	if (!e) return
	var e1 = e.slice(1, -1).replace(/\./g, "_");
	if (!results[e1]) {
		console.log(e1)
		editor.navigateRight()
		return
	}
	var replacement = `\\eqref{eq${e1}}`
    editor.insert(replacement)
}

function computeLabels() {
    var v = editor.getValue();
    var re = /\\label{eq([\d_\w]*)}/g
    var results = {}
    var m
    while ((m = re.exec(v))) {
        results[m[1]] = 1
    }
    return results
}
function convertNumbers() {
	var results = computeLabels();
    var v1 = v.replace(/\(\d+\.\d+\.\d+\w*\)/g, function(e) {
        var e1 = e.slice(1, -1).replace(/\./g, "_");
        if (!results[e1]) {
            console.log(e1)
            return e
        }
        return `\\eqref{eq${e1}}`
    })
    if (v1 != v) editor.setValue(v1)
}

function fixBibliography() {
    var newValue = editor.getValue() .replace(/(\\bibitem{book\d+}\s*)([^\d\\\n]+)(\d{4}\b).?\s*/g, function(_, intro, names, number) {

        var newNames = names.replace(/([^\s,.]+),?\s+(\w{1,3}\.(\s*\w{1,3}\.)*)/g, function(_, x1, x2) {
            return x1 + " " + x2.replace(/[\s.]/g, "")
        }).trim()
        console.log(newNames)


        return intro + newNames + " (" + number + ") "

    })
    editor.setValue(newValue)
}

function randomStuff() {

value = "\\bibitem{book19}\n\
	Uflyand, Ya.1968. Integral Transformations in Problems of the Elasticity Theory. Leningrad. Nauka. 402 (in Russian).   \
"

value.replace(/(\\bibitem{book\d+}\s*)([^\d\\\n]+)(\d+).?\s*/g, function(_, intro, names, number) {
 
   /* var parts = names.split(",")
    var newNames = []
    for (var i = 0; i< parts.length; i++) {
        var lastName = parts[i].trim() 
        var initials = parts[i + 1].replace(/[\s\.]/g, "")
        i++
        newNames.push(lastName + " " + initials)
    }
        */

    var newNames = names.replace(/([^\s,.]+),?\s+(\w{1,3}\.(\s*\w{1,3}\.)*)/g, function(_, x1, x2) {
        return x1 + " " + x2.replace(/[\s.]/g, "")
    }).trim()
    console.log(newNames)
    
     
    return intro + newNames + " (" + number + ") " 
    
})
}

function removeAlignement() {
    v=editor.getValue().replace(/\\(begin|end){aligned}/g, "")
    .replaceAll("\\right.", "").replaceAll("\\left.", "")
    .replaceAll("\\right", "").replaceAll("\\left", "")

    .replaceAll(/\\\\/g, "") .replaceAll(/&/g, "")
    .replaceAll(/\\\\/g, "") .replaceAll(/&/g, "")
    .replaceAll(/ *\+ *\n *\+/g, " +\n")
    .replaceAll(/ *\- *\n *\-/g, " -\n")
    .replaceAll(/ *\\times  *\n *\\times/g, " \\times\n")
    console.log(v)

}

window.onpagehide = function() {
	localStorage.lastValue = editor.getValue();
	localStorage.lastSelection = JSON.stringify(editor.selection.toJSON());
	localStorage.scrollTop = editor.session.getScrollTop()
    localStorage.panelScrollTop = sidePanel.scrollTop
}



function importHtml(html) {
	if (div) div.remove()
	div = document.createElement("div")
    div.innerHTML = html 
    console.log(html)
	document.body.appendChild(div)
}

var html, div
editor.addEventListener("paste", function name(params) {
    
    var pastedHtml = params.event.clipboardData.getData("text/html")
    if (pastedHtml)
        html = pastedHtml;
})
//https://www.tablesgenerator.com/latex_tables
async function importTableFromHTML(htmlArg) { 
    if (typeof htmlArg != "string") {
        var clipboardContents = await navigator.clipboard.read(["text/html"])
        for (var item of clipboardContents) {
            for (var mimeType of item.types) {
                if (mimeType === "text/html") {
                    var blob = await item.getType("text/html");
                    var blobText = await blob.text();
                    html = blobText
                }
            }
        } 
    } else {
        html = htmlArg
    }
    importHtml(html)
    
    
	tt = div.querySelectorAll("table")
    var table = tt[0]; 

    var result = readTableFromDom(table);

    editor.setValue(result)

}

function readTableFromDom(table) {
    
    var domRows = Array.from(table.querySelectorAll(":scope>tbody>tr, :scope>thead>tr, :scope>tr"))

    var tableData = []
    var columnCount = 0
    domRows.forEach(function(row, i) {
        var rowData = tableData[i] || (tableData[i] = [])
        var cellIndex = 0
        Array.from(row.children).forEach(function(cell, j) {
            // todo: nested tables
            // todo multiline cells \begin{tabular}{@{}c@{}}line1 \\ line2 \end{tabular}
            // or p type cells
            // \begin{tabular}{l|p{15mm}}
            // \hline
            // foo & bar \newline rlz \\
            // \hline
            // \end{tabular}
            // or
            // \makecell{ line1 \\ line2 } 
            var cellData = {
                text: cell.textContent.trim(),
                rowSpan: cell.rowSpan,
                colSpan: cell.colSpan
            }
            while (rowData[cellIndex]) cellIndex++
            rowData[cellIndex] = cellData
            if (cellData.colSpan > 1) {
                for (var k = 1; k < cellData.colSpan; k++) {
                    rowData[cellIndex + k] = "<<"
                }
            }
            if (cellData.rowSpan > 1) {
                for (var r = 1; r < cellData.rowSpan; r++) {
                    var nextRow = tableData[i + r] || (tableData[i + r] = [])
                    nextRow[cellIndex] = {
                        fromAbove: true,
                        text: "",
                        rowSpan: cellData.rowSpan - r,
                        colSpan: cellData.colSpan
                    }
                    for (var c = 1; c < cellData.colSpan; c++) {
                        nextRow[cellIndex + c] = "<<"
                    }
                }
            }
            cellIndex += cellData.colSpan
        })
        if (rowData.length > columnCount) columnCount = rowData.length
    });

    var texRows = tableData.map(rowData => {
		var cells = [];
		var clineSpans = []
		var clineStart = 0
        for (var j = 0; j < rowData.length; j++) {
            var cellData = rowData[j];
            if (cellData == "<<") {
                continue
            }
            var cellText = cellData.text
            if (cellData.rowSpan > 1 && !cellData.fromAbove) {
                cellText = `\\multirow{${cellData.rowSpan}}{*}{${cellText}}`
            }
            if (cellData.rowSpan > 1) {
                if (clineStart < j) {
                    clineSpans.push([clineStart, j])
                }
                clineStart = j + cellData.colSpan
            }
            if (cellData.colSpan > 1) {
                cellText = `\\multicolumn{${cellData.colSpan}}{|c|}{${cellText}}`
            }
            cells.push(cellText)
        }
		if (clineStart < j) {
			clineSpans.push([clineStart, j])
		}

		var cline = clineSpans.length == 1 && clineSpans[0][0] == 0 && clineSpans[0][1] == columnCount
            ? "\\hline"
            : clineSpans.map(x=>`\\cline{${x[0]+1}-${x[1]}}`).join(" ");
		return cells.join("\t&\t") + "\\\\  " + cline + "\n"
    });

    var result = formatTable(
        texRows.length > 30,
        "t",
        "|" + "c|".repeat(columnCount),
        "TODO: add caption",
        "tab:0000", "\\hline\n" + texRows.join("")
    );
    return result;
}

function formatTable(long, placement, align, caption, label, tabular) {
    if (long) {
        return `\\begin{longtable}[${placement}]{${align}}
    \\caption{
        ${caption}
    }
    \\label{${label}} \\\\ ${tabular}
\\end{longtable}
`;
    } else {
        return `\\begin{table}[${placement}]
    \\centering
    \\caption{
        ${caption}
    }
    \\label{${label}}
    \\begin{tabular}{${ align }} ${tabular}
    \\end{tabular}
\\end{table}
`;
    }
}

function convertToTable(text) {
    text = text.trim();
    var beginRe = /^\\begin{longtable}\[(\w+)\]{([\w|\s]+)}/;
    var captionRe = /\\caption{((?:[^}$]|\$[^$]+\$)*)}\s*/;
    var labelRe = /\\label{([^}]+)}\s*/;
    var m1 = beginRe.exec(text);
    if (!m1) return null;
    var placement = m1[1];
    var align = m1[2];
    var m2 = captionRe.exec(text);
    var caption = m2 ? m2[1].trim() : "";
    var m3 = labelRe.exec(text);
    var label = m3 ? m3[1].trim() : "";
    var tabular = text.replace(beginRe, "")
               .replace(captionRe, "")
               .replace(labelRe, "")
               .replace(/\\end{longtable}/, "")
               .replace(/^\s*\\\\/, "")
               .trim();
    return formatTable(false, placement, align, caption, label, tabular);
}
function convertToLongTable(text) {
    text = text.trim();
    var mainRe = /\\begin{tabular}{([\w|\s]+)}([\s\S]*?)\\end{tabular}/;
    var m = mainRe.exec(text);
    if (!m) return null;
    var tabular = m[2].trim();
    var align = m[1];

    var beginRe = /^\\begin{table}\[([\w!]+)\]/;
    var m1 = beginRe.exec(text);
    var placement = m1 ? m1[1] : "h";

    var captionRe = /\\caption{((?:[^}$]|\$[^$]+\$)*)}\s*/;
    var labelRe = /\\label{([^}]+)}\s*/;

    var m2 = captionRe.exec(text);
    var caption = m2 ? m2[1].trim() : "";
    var m3 = labelRe.exec(text);
    var label = m3 ? m3[1].trim() : "";

    return formatTable(true, placement, align, caption, label, tabular);
}

function oldTable() {
    var line = editor.getSelectedText()
    var match = /[^\d]*([\d.]+)(.*)([\s\S]*)/g.exec(line)
    var number = formatRefNumber(match[1])
    var caption = match[2].trim().replace(/^}|\\textbf{}/g, "")
    var tabular = match[3]
    
    var rows = tabular.trim().split("\n");
    var l 
    rows.forEach(function(x) {
        if (l == null) l = x.split("\t").length
    })

    tabular = "\\begin{tabular}{|" +  "c| ".repeat(l) + "}\\hline \n"  
        + rows.map(x=>x.replace(/\t/g, " & ")).join("\\\\ \\hline \n")
        + "\\\\ \\hline \n \\end{tabular}"

    var replacement = `\\begin{table}[!h]
\\centering
\\caption{
${caption}
}
\\label{tab:${number}}

${tabular}
\\end{table}`

    editor.insert(replacement)
    editor.renderer.scrollCursorIntoView(null, 0.5)
    editor.focus()
}




function initializeFromHTML() {
    if (!html) return alert("paste html to import")
    html = html.replace(/<!\--\[if supportFields\]>([\s\S]*?)<!\[endif\]-\->/g, function(_, x) {
        return x.replace(/(MACROBUTTON|SEQ)[\s\S]*?MERGEFORMAT|VM[\d:]*/g, "")
            .replace(/\s*style=('[^']*'|"[^"]*")/g, "")
            .replace(/<\/?span>/g, "")
            .replace(/\s*/g, "")
    });
    importHtml(html)

    var text = ""

    function readDom(div) {
        for (var i = 0; i < div.childNodes.length; i++) {
            var child = div.childNodes[i]
            if (child.nodeType == Node.TEXT_NODE) {
                text += child.textContent;
                continue;
            }

            if (child.nodeType != Node.ELEMENT_NODE) continue


            var tagName = child.tagName.toLowerCase() 
            if (tagName == "style") continue
            
            if (tagName == "table") {
                text += "\n\n" + readTableFromDom(child) + "\n\n"
                continue
            }

            if (child.querySelector("table")) {
                readDom(child)
                continue
            }

            if (tagName == "p") {
                text += child.textContent.trimStart() + "\n\n"
            } else {
                text += child.textContent;
            }
        }
    }

    Array.from(div.querySelectorAll("b")).forEach(x=>{
        if (x.textContent.startsWith("\\textbf{")) return;
        if (/(References|Literature|литература)/i.test(x.textContent)) return;
        if (x.textContent.trim() == "") return;
        x.textContent = "\\textbf{" + x.textContent + "}"
    })
    // Array.from(div.querySelectorAll("i")).forEach(x=>x.textContent = "\\textit{" + x.textContent + "}")
    readDom(div);


    text = text.replace(/\xa0/g, " ");

    var maskedText = applyInclusionRe(text, eqInclusionRe);

    var offsets = []
    maskedText.replace(/\n[ \t]*\n\s*/g, function(_, offset) {
        offsets.push([offset, _.length]);
    });
    var newText = "";
    var lastIndex = 0;
    for (var i = 0; i < offsets.length; i++) {
        var offset = offsets[i][0];
        var length = offsets[i][1];
        newText += text.slice(lastIndex, offset) + "\n";
        lastIndex = offset + length;
    }
    newText += text.slice(lastIndex);

    
    // TODO: convert all equations to inline in text instead of editor
    editor.setValue(newText);

    editor.session.markUndoGroup();

    initialize();
    editor.session.markUndoGroup();
    
    editor.selection.moveTo(0, 0)
    var max = 100000
    while(findNext(inlineEqReg) && max-- >0) {
        convertToInline() 
    }
    editor.session.markUndoGroup();

    // convert numbered equations
    editor.selection.moveTo(0, 0)
    var max = 10000
    while(findNext(eqRegStrict) && max-- >0) {
        replaceNumberedEquation() 
    }
    editor.session.markUndoGroup();

    div.remove();
}




function renderPreview(text) {
    var text = text.trim();
    console.log("rendering ", text)
    var displayMode = !/\$/.test(text);

    text = text.replace(/^(\$|\\\[|\\begin{(equation)\*?})\s*/s, "")
         .replace(/(\$|\\\]|\\end{(equation).*)$/s, "")
         .replace(/\\label{[^}]*}/g, "")

    var element = document.createElement("div")
    element.style.padding = "5px"
    katex.render(text, element, {
        throwOnError: false,
        displayMode,
        macros: {
        },
        output: "htmlAndMathml"
    });
    return element
}

var HoverTooltip = ace.require("ace/tooltip").HoverTooltip;
var Range = ace.require("ace/range").Range;
var docTooltip = new HoverTooltip();

var savedValue = null
editor.on("change", function() {
    savedValue = null
});

docTooltip.setDataProvider(function(e, editor) {
    var renderer = editor.renderer;

    var session = editor.session;
    var docPos = e.getDocumentPosition();

    if (!savedValue) {
        savedValue = editor.getValue();

        savedValue = applyInclusionRe(savedValue, eqInclusionRe);
    }

    var index = session.doc.positionToIndex(docPos, 0);

    eqInclusionRe.lastIndex = 0;
    var m = null;
    var hover = null;
    while ((m = eqInclusionRe.exec(savedValue))) {
        var start = m.index;
        var end = eqInclusionRe.lastIndex;
        if (index >= start && index <= end) {
            var text = m[0];
            var startPos = session.doc.indexToPosition(start, 0);
            var endPos = session.doc.indexToPosition(end, 0);
            var range = Range.fromPoints(startPos, endPos);
            hover = { text, range };
            break;
        }
        if (index < start) {
            break;
        }
    }

    if (hover) {
        var domNode = renderPreview(hover.text);
        docTooltip.showForRange(editor, hover.range, domNode, e);
    }
});

docTooltip.addToEditor(editor)



var diffView = null;
var newEditor = null;
function toggleDiffView() {

    var UndoManager = ace.require("ace/undomanager").UndoManager;
    UndoManager.prototype.toJSON = function () {
        return {
            $redoStack: this.$redoStack,
            $undoStack: this.$undoStack,
            $rev: this.$rev,
            mark: this.mark
        };
    };
    UndoManager.prototype.fromJSON = function (json) {
        this.reset();
        this.$undoStack = json.$undoStack;
        this.$redoStack = json.$redoStack;
        
        this.$rev = json.$rev;
        this.mark = json.mark;
        this.$redoStackBaseRev = json.$rev;
    };


    if (diffView) {
        diffView.detach();
        newEditor.container.remove();
        newEditor.destroy();
        diffView = newEditor = null;
    } else {
        var json = editor.session.toJSON()

        var session = ace.createEditSession(json.value, json.mode)
        session.setOptions({
            wrap: editor.session.getOption("wrap"),
            tabSize: editor.session.getOption("tabSize"),
            useSoftTabs: editor.session.getOption("useSoftTabs"),
        });
        diffView = require("ace/ext/diff").createDiffView({
            editorB: editor, 
            sessionA: session
        })
        newEditor = diffView.editorA;
        // newEditor.setOption("readOnly", true);
        newEditor.container.style.flex = 1
        container.appendChild(newEditor.container)

        json.history = JSON.parse(JSON.stringify(json.history));
        session.getUndoManager().fromJSON(json.history)
    }

}

</script>

<!--



testHML=`<table><tbody>
  <tr>
    <th  colspan="2" rowspan="2">mm888888888888888888888888888888</th>
    <th >a</th>
    <th >b</th>
    <th >c</th>
  </tr>
  <tr>
    <th >d</th>
    <th >e</th>
    <th >f</th>
  </tr> 

  <tr>
    <td >x</td>
    <td >y</td>
    <td >z</td>
    <td  colspan="2" rowspan="2">xxx99</td>
  </tr>
  <tr>
    <td >1</td>
    <td >2</td>
    <td >3</td>
  </tr>
</tbody>
</table>`

impiortHtml(testHML)
importTableFromHTML()

testOutput=`\begin{longtable}[t]{|c|c|c|c|c|}
    \caption{Dimensionless values of frequencies and critical forces}
    \label{tab:1} \\

\hline
\multicolumn{2}{|c|}{\multirow{2}{*}{mm888888888888888888888888888888}}	&	a	&	b	&	c\\ 
 \cline{4-5}
\multicolumn{2}{|c|}{}	&	d	&	e	&	f\\ 
 \cline{1-5}
x	&	y	&	z	&	\multicolumn{2}{|c|}{\multirow{2}{*}{xxx99}}\\ 
 \cline{1-3}
1	&	2	&	3 & \multicolumn{2}{|c|}{}\\ 
 \cline{1-5}

          
\end{longtable}`



// editor.addEventListener("paste", function name(params) {
//     html = params.event.clipboardData.getData("text/html")
//     div = document.createElement("div")
//     div.innerHTML = html 
//     console.log(html)
// })



findNext(/\\(?:text|operatorname){(sh|ch)}/g, null, eqAndBibExclusionRe) 



// require("ace/ext/diff").createDiffView({
//     editorA: editor 
// })
editor.session.


-->

